// üöÄ GizeBets Modular Bot Commands - Clean & Organized Architecture
// This replaces the monolithic bot-commands.js with a modular approach

const ContentCommands = require('./bot-modules/content-commands');
const SystemCommands = require('./bot-modules/system-commands');
const LiveCommands = require('./bot-modules/live-commands');
const AdminCommands = require('./bot-modules/admin-commands');
const AutomationCommands = require('./bot-modules/automation-commands');
const HelpCommand = require('./bot-modules/help-command');

class GizeBotCommands {
  constructor() {
    // Initialize all command modules
    this.contentCommands = new ContentCommands();
    this.systemCommands = new SystemCommands();
    this.liveCommands = new LiveCommands();
    this.adminCommands = new AdminCommands();
    this.automationCommands = new AutomationCommands();
    this.helpCommand = new HelpCommand();

    // Use the base bot instance (they all inherit from BaseBotCommands)
    this.bot = this.contentCommands.bot;
    this.channelId = this.contentCommands.channelId;
    this.adminUsers = this.contentCommands.adminUsers;
    this.baseUrl = this.contentCommands.baseUrl;
    this.isPollingActive = this.contentCommands.isPollingActive;
    this.systemStatus = this.contentCommands.systemStatus;
    this.metrics = this.contentCommands.metrics;

    // Legacy compatibility properties
    this.heartbeatInterval = this.contentCommands.heartbeatInterval;
    this.lastHeartbeat = this.contentCommands.lastHeartbeat;
    this.webhookManager = this.contentCommands.webhookManager;

    console.log('üß© Modular Bot Commands initialized');
  }

  // üìù Set bot commands using official Telegram API
  async setupBotCommands() {
    try {
      console.log('ü§ñ Setting up bot commands...');
      
      // Define commands according to Telegram Bot API standards
      const commands = [
        // Content Management
        { command: 'predictions', description: '‚öΩ Send match predictions manually' },
        { command: 'sendpromo', description: 'üéÅ Send promotional message' },
        { command: 'results', description: 'üìä Send match results' },
        
        // Live Matches Management
        { command: 'active_matches', description: 'üî¥ Show current active matches' },
        { command: 'upcoming_matches', description: '‚è∞ Show upcoming matches (next 2-3 hours)' },
        { command: 'today_matches', description: 'üìÖ Today\'s matches with content schedule' },
        { command: 'send_live', description: 'üì∫ Send predictions for live matches' },
        { command: 'live_results', description: '‚ö° Post live match results' },
        
        // Automation Control
        { command: 'automation', description: 'ü§ñ Control automation settings' },
        { command: 'schedule', description: '‚è∞ Manage posting schedule' },
        { command: 'settings', description: '‚öôÔ∏è System configuration' },
        
        // Analytics & Monitoring
        { command: 'analytics', description: 'üìä View channel analytics' },
        { command: 'coupons', description: 'üé´ Manage promotional coupons' },
        { command: 'scrape_website', description: 'üï∑Ô∏è Scrape GizeBets website for data' },
        { command: 'compare_data', description: 'üìä Compare API vs Website data' },
        { command: 'status', description: 'üìà Get system status' },
        
        // System Control
        { command: 'stop', description: 'üõë Stop system processes' },
        { command: 'restart', description: 'üîÑ Restart bot system' },
        { command: 'force_stop', description: 'üî• Force stop all bot instances' },
        { command: 'health', description: 'üè• Detailed health check' },
        { command: 'help', description: '‚ùì Show admin panel' }
      ];

      // Register commands with Telegram using setMyCommands
      console.log('üîß About to register commands with Telegram...');
      console.log('üîß Commands to register:', commands.length);
      await this.bot.setMyCommands(commands);
      console.log('‚úÖ Bot commands registered successfully');
      
      return true;
    } catch (error) {
      console.error('‚ùå Error setting up bot commands:', error.message);
      console.error('‚ùå Full error:', error);
      return false;
    }
  }

  // üîß Setup all command handlers from modules
  setupAllCommands() {
    console.log('üîß Setting up all command handlers...');

    // Content commands
    this.contentCommands.setupContentCommands();
    
    // System commands
    this.systemCommands.setupSystemCommands();
    
    // Live commands
    this.liveCommands.setupLiveCommands();
    
    // Admin commands
    this.adminCommands.setupAdminCommands();
    
    // Automation commands
    this.automationCommands.setupAutomationCommands();
    
    // Help command
    this.helpCommand.setupHelpCommand();

    // Setup callback handlers
    this.setupCallbackHandlers();

    console.log('‚úÖ All command handlers set up successfully');
  }

  // üîò Setup callback query handlers
  setupCallbackHandlers() {
    this.bot.on('callback_query', async (callbackQuery) => {
      const action = callbackQuery.data;
      const msg = callbackQuery.message;
      const chatId = msg.chat.id;
      const messageId = msg.message_id;
      const queryAge = Date.now() - (callbackQuery.message.date * 1000);

      try {
        // Check if callback query is too old
        if (queryAge > 50000) {
          console.log(`‚ö†Ô∏è Callback query too old (${queryAge}ms), skipping answer`);
          return;
        }
        
        console.log(`üîò Processing callback query: action="${action}", age=${queryAge}ms, chatId=${chatId}`);

        // Answer callback query immediately
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: 'Processing...',
          show_alert: false
        }).catch(err => {
          console.log(`‚ö†Ô∏è Failed to answer callback query: ${err.message}`);
        });

        // Handle different callback actions
          switch (action) {
          case 'quick_predictions':
            await this.contentCommands.makeApiCall('/api/manual/predictions');
            await this.bot.editMessageText('‚úÖ Predictions sent to channel!', {
              chat_id: chatId, message_id: messageId
            });
            break;

          case 'quick_promo':
            await this.contentCommands.makeApiCall('/api/manual/promo', { category: 'football' });
            await this.bot.editMessageText('‚úÖ Promo sent to channel!', {
              chat_id: chatId, message_id: messageId
            });
            break;

          case 'quick_live_matches':
            await this.bot.editMessageText('üî¥ Fetching live matches...', {
              chat_id: chatId, message_id: messageId
            });
            // Delegate to live commands module
            setTimeout(() => {
              this.liveCommands.setupActiveMatchesCommand();
              this.bot.sendMessage(chatId, '/active_matches');
            }, 1000);
            break;

          case 'quick_status':
            const status = this.systemCommands.getStatus();
              await this.bot.editMessageText(
              `üìä **Quick Status**\n\n` +
              `ü§ñ Bot: ${status.isOnline ? '‚úÖ Online' : '‚ùå Offline'}\n` +
              `‚è∞ Uptime: ${status.uptimeFormatted}\n` +
              `‚ùå Errors: ${status.consecutiveErrors}\n` +
              `üì° Polling: ${status.isPollingActive ? '‚úÖ Active' : '‚ùå Inactive'}`,
              { chat_id: chatId, message_id: messageId, parse_mode: 'Markdown' }
            );
            break;

          case 'quick_health':
            await this.bot.editMessageText('üè• Running health check...', {
              chat_id: chatId, message_id: messageId
            });
            // Trigger health check
            setTimeout(() => {
              this.bot.sendMessage(chatId, '/health');
            }, 1000);
            break;

          case 'quick_analytics':
            await this.bot.editMessageText('üìä Fetching analytics...', {
              chat_id: chatId, message_id: messageId
            });
            setTimeout(() => {
              this.bot.sendMessage(chatId, '/analytics');
            }, 1000);
            break;

          case 'quick_settings':
            await this.bot.editMessageText('‚öôÔ∏è Loading settings...', {
              chat_id: chatId, message_id: messageId
            });
            setTimeout(() => {
              this.bot.sendMessage(chatId, '/settings');
            }, 1000);
            break;

          case 'quick_restart':
            await this.bot.editMessageText('üîÑ Restarting bot...', {
              chat_id: chatId, message_id: messageId
            });
            setTimeout(() => {
              this.bot.sendMessage(chatId, '/restart');
            }, 1000);
            break;

          case 'show_command_list':
            await this.helpCommand.showCommandList(chatId, messageId);
            break;
          
          case 'back_to_main_menu':
            // Re-trigger help command
            setTimeout(() => {
              this.bot.sendMessage(chatId, '/help');
            }, 500);
              await this.bot.deleteMessage(chatId, messageId);
            break;

          case 'cancel_operation':
            await this.bot.editMessageText('‚ùå Operation cancelled.', {
              chat_id: chatId, message_id: messageId
            });
            break;

          default:
            console.log(`‚ùì Unknown callback action: ${action}`);
            await this.bot.editMessageText('‚ùì Unknown action.', {
              chat_id: chatId, message_id: messageId
            });
        }

      } catch (error) {
        console.error('‚ùå Error in callback handler:', error);
        try {
          await this.bot.editMessageText('‚ùå Error processing request.', {
            chat_id: chatId, message_id: messageId
          });
        } catch (editError) {
          console.error('‚ùå Failed to edit error message:', editError);
        }
      }
    });
  }

  // üöÄ Start the bot commands system
  async startBotCommands() {
    try {
      console.log('üöÄ Starting GizeBets Bot Commands...');
      console.log('üîß Token check:', !!process.env.TELEGRAM_BOT_TOKEN);
      console.log('üîß About to setup bot commands...');

      // Set up commands with Telegram
      await this.setupBotCommands();
      console.log('‚úÖ Bot commands setup completed');

      // Set up all command handlers
      this.setupAllCommands();

      // Start bot communication
      if (this.contentCommands.useWebhook) {
        console.log('üåê Setting up WEBHOOK mode...');
        await this.setupWebhook();
      } else {
        console.log('üîß Starting POLLING mode...');
        await this.contentCommands.webhookManager.prepareForPolling();
        console.log('‚úÖ No webhook configured, ready for polling');
        
        // ‚úÖ Correct syntax for startPolling (parameters at top level)
        await this.bot.startPolling({
          interval: 2000,
          timeout: 10,
          allowed_updates: ['message', 'callback_query']
        });
      }
      
      this.isPollingActive = true;
      this.contentCommands.isPollingActive = true;
      this.systemCommands.isPollingActive = true;
      this.liveCommands.isPollingActive = true;
      this.adminCommands.isPollingActive = true;
      this.automationCommands.isPollingActive = true;
      this.helpCommand.isPollingActive = true;

      console.log('‚úÖ Bot polling started successfully with enhanced stability');

      // Notify admin
      console.log(`‚úÖ Bot @${this.bot.options.username || 'GizeBetsBot'} is ready for admin commands!`);
      console.log('üìã Commands: /sendpromo, /sendbonus, /predictions, /results, /status, /help');
      console.log('üîí Admin users:', this.adminUsers);

      // Send startup notification to admins
      await this.contentCommands.notifyAdmins(
        'üöÄ **BOT STARTED**', 
        '‚úÖ GizeBets Bot is now online and ready!\nüïê ' + new Date().toLocaleString('en-US', { timeZone: 'Africa/Addis_Ababa' })
      );

      return true;

    } catch (error) {
      console.error('‚ùå Critical error starting bot commands:', error);
      this.isPollingActive = false;
      throw error;
    }
  }

  // üîß Start method (alias for compatibility)
  async start() {
    return await this.startBotCommands();
  }

  // üõë Stop the bot
  async stop() {
    console.log('üõë Stopping modular bot...');
    
    // Stop all modules
    await Promise.all([
      this.contentCommands.stop(),
      this.systemCommands.stop(),
      this.liveCommands.stop(),
      this.adminCommands.stop(),
      this.automationCommands.stop(),
      this.helpCommand.stop()
    ]);

        this.isPollingActive = false;
    console.log('‚úÖ Modular bot stopped');
        return true;
      }

  // üìä Get status (delegate to base class)
  getStatus() {
    return this.contentCommands.getStatus();
  }

  // üì¢ Notify admins (delegate to base class)
  async notifyAdmins(title, message) {
    return await this.contentCommands.notifyAdmins(title, message);
  }

  // üîí Check admin access (delegate to base class)
  checkAdminAccess(msg) {
    return this.contentCommands.checkAdminAccess(msg);
  }

  // üõ°Ô∏è Admin verification (delegate to base class)
  isAdmin(userId) {
    return this.contentCommands.isAdmin(userId);
  }

  // üåê Setup webhook for Vercel/Serverless environments
  async setupWebhook() {
    try {
      const webhookUrl = `${this.contentCommands.baseUrl}/api/webhook/telegram`;
      console.log('üåê Setting webhook to:', webhookUrl);
      
      // Set the webhook
      const result = await this.bot.setWebHook(webhookUrl, {
        allowed_updates: ['message', 'callback_query'],
        max_connections: 40,
        drop_pending_updates: true
      });
      
      if (result) {
        console.log('‚úÖ Webhook set successfully');
        
        // Verify webhook info
        const webhookInfo = await this.bot.getWebHookInfo();
        console.log('üîç Webhook info:', {
          url: webhookInfo.url,
          has_custom_certificate: webhookInfo.has_custom_certificate,
          pending_update_count: webhookInfo.pending_update_count,
          max_connections: webhookInfo.max_connections
        });
        
      return true;
      } else {
        console.error('‚ùå Failed to set webhook');
        return false;
      }
    } catch (error) {
      console.error('‚ùå Error setting up webhook:', error);
      return false;
    }
  }
}

module.exports = GizeBotCommands;